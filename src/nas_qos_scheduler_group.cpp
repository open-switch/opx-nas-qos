/*
 * Copyright (c) 2019 Dell Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
 * LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS
 * FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
 *
 * See the Apache Version 2.0 License for specific language governing
 * permissions and limitations under the License.
 */

/*!
 * \file   nas_qos_scheduler_group.cpp
 * \brief  NAS QOS SCHEDULER_GROUP Object
 * \date   05-2015
 * \author
 */

#include "event_log.h"
#include "std_assert.h"
#include "nas_qos_scheduler_group.h"
#include "dell-base-qos.h"
#include "nas_qos_switch.h"
#include "hal_if_mapping.h"

nas_qos_scheduler_group::nas_qos_scheduler_group (nas_qos_switch* p_switch)
           : base_obj_t (p_switch)
{
    memset(&cfg, 0, sizeof(cfg));
    child_list = std::vector<nas_obj_id_t>();
    ndi_port_id = {0};
    scheduler_group_id = 0;
    ndi_scheduler_group_id = 0;
}

const nas_qos_switch& nas_qos_scheduler_group::get_switch()
{
    return static_cast<const nas_qos_switch&> (base_obj_t::get_switch());
}


void nas_qos_scheduler_group::commit_create (bool rolling_back)

{
    if ((!is_attr_dirty (BASE_QOS_SCHEDULER_GROUP_PORT_ID)) ||
        (!is_attr_dirty (BASE_QOS_SCHEDULER_GROUP_LEVEL)) ||
        (!is_attr_dirty (BASE_QOS_SCHEDULER_GROUP_SCHEDULER_PROFILE_ID)) ||
        (!is_attr_dirty (BASE_QOS_SCHEDULER_GROUP_PARENT)) ||
        (!is_attr_dirty (BASE_QOS_SCHEDULER_GROUP_MAX_CHILD)))    {
        throw nas::base_exception {NAS_BASE_E_CREATE_ONLY,
                        __PRETTY_FUNCTION__,
                        "Mandatory attributes are not present"};
    }

    base_obj_t::commit_create(rolling_back);
}

void* nas_qos_scheduler_group::alloc_fill_ndi_obj (nas::mem_alloc_helper_t& m)
{
    // NAS Qos scheduler_group does not allocate memory to save the incoming tentative attributes
    return this;
}

bool nas_qos_scheduler_group::push_create_obj_to_npu (npu_id_t npu_id,
                                     void* ndi_obj)
{
    ndi_obj_id_t ndi_scheduler_group_id;
    t_std_error rc;

    EV_LOGGING(QOS, DEBUG, "NAS-QOS", "Creating obj on NPU %d", npu_id);

    nas_qos_scheduler_group * nas_qos_scheduler_group_p = static_cast<nas_qos_scheduler_group*> (ndi_obj);

    // form attr_list
    std::vector<uint64_t> attr_list;
    attr_list.resize(_set_attributes.len());

    uint_t num_attr = 0;
    for (auto attr_id: _set_attributes) {
        attr_list[num_attr++] = attr_id;
    }

    ndi_qos_scheduler_group_struct_t  ndi_sg = {0};
    ndi_sg.level = nas_qos_scheduler_group_p->cfg.level;
    ndi_sg.ndi_port = nas_qos_scheduler_group_p->ndi_port_id;
    ndi_sg.max_child = nas_qos_scheduler_group_p->cfg.max_child;

    nas_qos_switch& p_switch = const_cast <nas_qos_switch &> (get_switch());
    ndi_sg.parent = p_switch.nas2ndi_scheduler_group_id(nas_qos_scheduler_group_p->cfg.parent);

    if (is_attr_dirty(BASE_QOS_SCHEDULER_GROUP_SCHEDULER_PROFILE_ID))
          ndi_sg.scheduler_profile_id =
                  p_switch.nas2ndi_scheduler_profile_id(
                                      nas_qos_scheduler_group_p->cfg.scheduler_profile_id,
                                      npu_id);

    EV_LOGGING(QOS, DEBUG, "NAS-QOS", "Creating obj on NPU %d, npu_id %u, port_id %u", npu_id, ndi_sg.ndi_port.npu_id, ndi_sg.ndi_port.npu_port);


    if ((rc = ndi_qos_create_scheduler_group (npu_id,
                                   &attr_list[0],
                                   num_attr,
                                   &ndi_sg,
                                   &ndi_scheduler_group_id))
            != STD_ERR_OK)
    {
        EV_LOGGING(QOS, DEBUG, "NAS-QOS", "Creating scheduler group on NPU %d failed!", npu_id);
        throw nas::base_exception {rc, __PRETTY_FUNCTION__,
            "NDI QoS SCHEDULER_GROUP Create Failed"};
    }
    // Cache the new SCHEDULER_GROUP ID generated by NDI
    set_ndi_obj_id(npu_id, ndi_scheduler_group_id);

    return true;

}


bool nas_qos_scheduler_group::push_delete_obj_to_npu (npu_id_t npu_id)
{
    t_std_error rc;

    EV_LOGGING(QOS, DEBUG, "NAS-QOS", "Deleting obj on NPU %d", npu_id);

    if ((rc = ndi_qos_delete_scheduler_group(npu_id, ndi_obj_id(npu_id)))
        != STD_ERR_OK)
    {
        throw nas::base_exception {rc, __PRETTY_FUNCTION__,
            "NDI SCHEDULER_GROUP Delete Failed"};
    }

    return true;
}

bool nas_qos_scheduler_group::is_leaf_attr (nas_attr_id_t attr_id)
{
    // Table of function pointers to handle modify of Qos scheduler_group
    // attributes.
    static const std::unordered_map <BASE_QOS_SCHEDULER_GROUP_t,
                                     bool,
                                     std::hash<int>>
        _leaf_attr_map =
    {
        // modifiable objects
        {BASE_QOS_SCHEDULER_GROUP_PORT_ID,      true},
        {BASE_QOS_SCHEDULER_GROUP_LEVEL,        true},
        {BASE_QOS_SCHEDULER_GROUP_MAX_CHILD,    true},
        {BASE_QOS_SCHEDULER_GROUP_SCHEDULER_PROFILE_ID, true},
        {BASE_QOS_SCHEDULER_GROUP_PARENT,       true},
    };

    return (_leaf_attr_map.at(static_cast<BASE_QOS_SCHEDULER_GROUP_t>(attr_id)));
}

bool nas_qos_scheduler_group::push_leaf_attr_to_npu (nas_attr_id_t attr_id,
                                           npu_id_t npu_id)
{
    t_std_error rc = STD_ERR_OK;

    EV_LOGGING(QOS, DEBUG, "QOS", "Modifying npu: %d, attr_id %lu",
                    npu_id, attr_id);

    ndi_qos_scheduler_group_struct_t ndi_sg = {0};
    nas_qos_switch& p_switch = const_cast <nas_qos_switch &> (get_switch());
    nas_obj_id_t nas_obj_id;

    switch (attr_id) {
    case BASE_QOS_SCHEDULER_GROUP_PORT_ID:
        ndi_sg.ndi_port = ndi_port_id;
        break;

    case BASE_QOS_SCHEDULER_GROUP_LEVEL:
        ndi_sg.level = get_level();
        break;

    case BASE_QOS_SCHEDULER_GROUP_MAX_CHILD:
        ndi_sg.max_child = get_max_child();
        break;

    case BASE_QOS_SCHEDULER_GROUP_SCHEDULER_PROFILE_ID:
        nas_obj_id = get_scheduler_profile_id();
        ndi_sg.scheduler_profile_id = p_switch.nas2ndi_scheduler_profile_id(nas_obj_id, npu_id);
        break;

    case BASE_QOS_SCHEDULER_GROUP_PARENT:
        nas_obj_id = get_parent();
        ndi_sg.parent = p_switch.nas2ndi_scheduler_group_id(nas_obj_id);
        break;

    default:
            STD_ASSERT (0); //non-modifiable object
    }

    rc = ndi_qos_set_scheduler_group_attr(npu_id,
                                   ndi_obj_id(npu_id),
                                   (BASE_QOS_SCHEDULER_GROUP_t)attr_id,
                                   &ndi_sg);
    if (rc != STD_ERR_OK) {
        throw nas::base_exception {rc, __PRETTY_FUNCTION__,
            "NDI attribute Set Failed"};
    }

    return true;
}



t_std_error nas_qos_scheduler_group::set_port_id(hal_ifindex_t ifindex)
{
    mark_attr_dirty(BASE_QOS_SCHEDULER_GROUP_PORT_ID);
    cfg.port_id = ifindex;

    // populate the ndi-port cache
    interface_ctrl_t intf_ctrl;
    intf_ctrl.q_type = HAL_INTF_INFO_FROM_IF;
    intf_ctrl.if_index = ifindex;
    intf_ctrl.vrf_id = 0; //default vrf
    if (dn_hal_get_interface_info(&intf_ctrl) != STD_ERR_OK) {
        EV_LOGGING(QOS, NOTICE, "QOS",
                     "Cannot find NPU id for ifIndex: %d",
                        ifindex);
        return STD_ERR(QOS, CFG, 0);
    }
    ndi_port_id.npu_id = intf_ctrl.npu_id;
    ndi_port_id.npu_port = intf_ctrl.port_id;

    return STD_ERR_OK;
}

