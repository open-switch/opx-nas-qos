/*
 * Copyright (c) 2016 Dell Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
 * LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS
 * FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
 *
 * See the Apache Version 2.0 License for specific language governing
 * permissions and limitations under the License.
 */

/*!
 * \file   nas_qos_buffer_pool.cpp
 * \brief  NAS QOS buffer_pool Object
 * \date   03-2016
 * \author
 */

#include "event_log.h"
#include "std_assert.h"
#include "nas_qos_buffer_pool.h"
#include "nas_ndi_qos.h"
#include "nas_qos_switch.h"

nas_qos_buffer_pool::nas_qos_buffer_pool (nas_qos_switch* p_switch)
           : base_obj_t (p_switch)
{
    memset(&cfg, 0, sizeof(cfg));
    buffer_pool_id = 0;
}

const nas_qos_switch& nas_qos_buffer_pool::get_switch()
{
    return static_cast<const nas_qos_switch&> (base_obj_t::get_switch());
}


void nas_qos_buffer_pool::commit_create (bool rolling_back)

{
    base_obj_t::commit_create(rolling_back);
}

void* nas_qos_buffer_pool::alloc_fill_ndi_obj (nas::mem_alloc_helper_t& m)
{
    // NAS Qos buffer_pool does not allocate memory to save the incoming tentative attributes
    return this;
}

bool nas_qos_buffer_pool::push_create_obj_to_npu (npu_id_t npu_id,
                                     void* ndi_obj)
{
    ndi_obj_id_t ndi_buffer_pool_id;
    t_std_error rc;

    EV_LOGGING(QOS, DEBUG, "NAS-QOS", "Creating obj on NPU %d", npu_id);

    nas_qos_buffer_pool * bp = static_cast<nas_qos_buffer_pool*> (ndi_obj);
    qos_buffer_pool_struct ndi_cfg = {0};

    // form attr_list
    std::vector<uint64_t> attr_list;
    attr_list.resize(_set_attributes.len());

    uint_t num_attr = 0;
    for (auto attr_id: _set_attributes) {
        attr_list[num_attr++] = attr_id;
    }

    nas_qos_switch & nas_switch = const_cast<nas_qos_switch &>(get_switch());

    ndi_cfg.size = bp->cfg.size;
    ndi_cfg.threshold_mode = bp->cfg.threshold_mode;
    ndi_cfg.type = bp->cfg.type;
    ndi_cfg.wred_profile_id = nas_switch.nas2ndi_wred_profile_id(bp->cfg.wred_profile_id, npu_id);
    ndi_cfg.xoff_size = bp->cfg.xoff_size;


    if ((rc = ndi_qos_create_buffer_pool (npu_id,
                                   &attr_list[0],
                                   num_attr,
                                   &ndi_cfg,
                                   &ndi_buffer_pool_id))
            != STD_ERR_OK)
    {
        throw nas::base_exception {rc, __PRETTY_FUNCTION__,
            "NDI QoS buffer_pool Create Failed"};
    }
    // Cache the new buffer_pool ID generated by NDI
    set_ndi_obj_id(npu_id, ndi_buffer_pool_id);

    // Cache the shadow buffer pool IDs
    // First reset
    reset_shadow_buffer_pool_ids();

    // Get from SAI
    uint_t count = ndi_qos_get_shadow_buffer_pool_list(
                            npu_id,
                            ndi_buffer_pool_id,
                            0, NULL);

    if (count == 0)
        return true;

    std::vector<ndi_obj_id_t> shadow_pool_list(count);

    if (ndi_qos_get_shadow_buffer_pool_list(
                            npu_id,
                            ndi_buffer_pool_id,
                            count,
                            &shadow_pool_list[0]) != count) {
        EV_LOGGING(QOS, ERR, "QOS-Pool",
                "Shadow buffer_pools get failed on ndi_pool_id 0x%016lx",
                ndi_buffer_pool_id);
        throw nas::base_exception {NAS_QOS_E_FAIL, __PRETTY_FUNCTION__,
            "NDI QoS buffer_pool Create Failed on Shadow Pool caching"};
    }

    // Populate local cache
    for (uint_t i = 0; i< count; i++)
        add_shadow_buffer_pool_id(shadow_pool_list[i]);

    return true;

}


bool nas_qos_buffer_pool::push_delete_obj_to_npu (npu_id_t npu_id)
{
    t_std_error rc;

    EV_LOGGING(QOS, DEBUG, "NAS-QOS", "Deleting obj on NPU %d", npu_id);

    if ((rc = ndi_qos_delete_buffer_pool(npu_id, ndi_obj_id(npu_id)))
        != STD_ERR_OK)
    {
        throw nas::base_exception {rc, __PRETTY_FUNCTION__,
            "NDI buffer_pool Delete Failed"};
    }

    return true;
}

bool nas_qos_buffer_pool::is_leaf_attr (nas_attr_id_t attr_id)
{
    // Table of function pointers to handle modify of Qos buffer_pool
    // attributes.
    static const std::unordered_map <BASE_QOS_BUFFER_POOL_t,
                                     bool,
                                     std::hash<int>>
        _leaf_attr_map =
    {
        // modifiable objects
        {BASE_QOS_BUFFER_POOL_SHARED_SIZE,    false},
        {BASE_QOS_BUFFER_POOL_POOL_TYPE, true},
        {BASE_QOS_BUFFER_POOL_SIZE, true},
        {BASE_QOS_BUFFER_POOL_THRESHOLD_MODE, true},
        {BASE_QOS_BUFFER_POOL_XOFF_SIZE, true},
        {BASE_QOS_BUFFER_POOL_WRED_PROFILE_ID, true},

        //The NPU ID list attribute is handled by the base object itself.
    };

    return (_leaf_attr_map.at(static_cast<BASE_QOS_BUFFER_POOL_t>(attr_id)));
}

bool nas_qos_buffer_pool::push_leaf_attr_to_npu (nas_attr_id_t attr_id,
                                           npu_id_t npu_id)
{
    t_std_error rc = STD_ERR_OK;

    EV_LOGGING(QOS, DEBUG, "QOS", "Modifying npu: %d, attr_id %lu",
                    npu_id, attr_id);

    qos_buffer_pool_struct_t ndi_cfg= {0};

    nas_qos_switch & nas_switch = const_cast<nas_qos_switch &>(get_switch());

    switch (attr_id) {
    case BASE_QOS_BUFFER_POOL_POOL_TYPE:
        ndi_cfg.type = get_type();
        break;

    case BASE_QOS_BUFFER_POOL_THRESHOLD_MODE:
        ndi_cfg.threshold_mode = get_threshold_mode();
        break;

    case BASE_QOS_BUFFER_POOL_SIZE:
        ndi_cfg.size = cfg.size;
        break;

    case BASE_QOS_BUFFER_POOL_XOFF_SIZE:
        ndi_cfg.xoff_size = get_xoff_size();
        break;

    case BASE_QOS_BUFFER_POOL_WRED_PROFILE_ID:
        ndi_cfg.wred_profile_id = nas_switch.nas2ndi_wred_profile_id(get_wred_profile_id(), npu_id);
        break;


    default:
        STD_ASSERT (0); //non-modifiable object
    }

    rc = ndi_qos_set_buffer_pool_attr(npu_id,
                                   ndi_obj_id(npu_id),
                                   (BASE_QOS_BUFFER_POOL_t)attr_id,
                                   &ndi_cfg);
    if (rc != STD_ERR_OK) {
            throw nas::base_exception {rc, __PRETTY_FUNCTION__,
                "NDI attribute Set Failed"};
    }

    return true;
}

uint32_t nas_qos_buffer_pool::get_shared_size(uint_t nas_mmu_index)
{
    npu_id_t npu_id;
    nas_attr_id_t nas_attr_list[1];
    qos_buffer_pool_struct ndi_cfg = {0};

    if (get_first_npu_id(npu_id) == false) {
        EV_LOGGING(QOS, ERR, "NAS-QOS",
                "npu_id not available, failed to get current buffer size");
        return 0;
    }

    ndi_obj_id_t ndi_pool_id = ndi_obj_id(npu_id);
    if (nas_mmu_index)
        ndi_pool_id = get_shadow_buffer_pool_id(nas_mmu_index);

    nas_attr_list[0] = BASE_QOS_BUFFER_POOL_SHARED_SIZE;
    if (ndi_qos_get_buffer_pool(npu_id,
                                ndi_pool_id,
                                nas_attr_list,
                                1,
                                &ndi_cfg) == STD_ERR_OK) {
        return ndi_cfg.shared_size;
    }
    else {
        return 0;
    }
}

uint32_t nas_qos_buffer_pool::get_size(uint_t nas_mmu_index)
{
    npu_id_t npu_id;
    nas_attr_id_t nas_attr_list[1];
    qos_buffer_pool_struct ndi_cfg = {0};
    uint_t size = cfg.size; //default is user-configured size at master pool

    if (get_first_npu_id(npu_id) == false) {
        EV_LOGGING(QOS, DEBUG, "NAS-QOS",
                "npu_id not available, return configured buffer size");
        return size;
    }

    ndi_obj_id_t ndi_pool_id = ndi_obj_id(npu_id);
    if (nas_mmu_index)
        ndi_pool_id = get_shadow_buffer_pool_id(nas_mmu_index);

    nas_attr_list[0] = BASE_QOS_BUFFER_POOL_SIZE;
    if (ndi_qos_get_buffer_pool(npu_id,
                                ndi_pool_id,
                                nas_attr_list,
                                1,
                                &ndi_cfg) == STD_ERR_OK) {
        return ndi_cfg.size;
    }
    else {
        return size;
    }
}
